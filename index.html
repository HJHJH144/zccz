<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>zc和lcz的温馨小窝</title>
    <link rel="stylesheet" href="style.css">
    <!-- PWA相关 -->
    <meta name="theme-color" content="#141e30">
    <meta name="description" content="zc和lcz的专属小窝，记录甜蜜时光">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="android-launchericon-192-192.png">
    <style>
        /* 确保最终屏幕上的按钮可见 */
        .action-buttons {
            display: flex !important;
            justify-content: center !important;
            gap: 20px !important;
            margin-top: 30px !important;
            flex-wrap: wrap !important;
        }

        #chatBtn {
            background: linear-gradient(45deg, #20bf55, #01baef) !important;
            font-weight: bold !important;
            padding: 12px 25px !important;
            animation: pulse 1.5s infinite !important;
            color: white !important;
            display: inline-block !important;
            border: none !important;
            border-radius: 30px !important;
            font-size: 16px !important;
            cursor: pointer !important;
            transition: all 0.3s ease !important;
            box-shadow: 0 5px 15px rgba(1, 186, 239, 0.4) !important;
        }

        /* 增强聊天容器的显示 */
        #chatContainer.visible {
            display: flex !important;
        }

        /* 确保聊天组件在页面上可见 */
        .chat-container {
            z-index: 10000 !important;
        }

        /* 确保聊天消息样式 */
        .message {
            padding: 10px 15px !important;
            border-radius: 15px !important;
            max-width: 75% !important;
            word-break: break-word !important;
            position: relative !important;
            margin-bottom: 20px !important;
        }

        .message.zc {
            background: linear-gradient(45deg, #ff758c, #ff7eb3) !important;
            align-self: flex-end !important;
            border-bottom-right-radius: 0 !important;
            color: white !important;
        }

        .message.lcz {
            background: rgba(255, 255, 255, 0.1) !important;
            align-self: flex-start !important;
            border-bottom-left-radius: 0 !important;
            color: white !important;
        }

        #replayBtn,
        #musicBtn {
            display: inline-block !important;
            margin: 10px !important;
        }

        .photo-frame {
            width: 300px !important;
            height: 200px !important;
            margin: 20px auto !important;
            border: 5px solid rgba(255, 117, 140, 0.8) !important;
            border-radius: 10px !important;
            overflow: hidden !important;
            background: rgba(255, 255, 255, 0.1) !important;
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(1, 186, 239, 0.6);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(1, 186, 239, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(1, 186, 239, 0);
            }
        }

        /* 强制显示最终屏幕的样式 */
        body,
        html {
            height: 100%;
            margin: 0;
            font-family: 'Microsoft YaHei', '微软雅黑', Arial, sans-serif;
            color: #fff;
            background: linear-gradient(135deg, #141e30, #243b55);
        }

        /* 消息加载状态样式 */
        .message-loading {
            opacity: 0.7;
            position: relative;
        }

        .message-loading-indicator {
            padding: 10px;
            text-align: center;
            color: #666;
            font-style: italic;
            font-size: 0.9em;
            animation: pulse 1.5s infinite ease-in-out;
        }

        @keyframes pulse {
            0% {
                opacity: 0.5;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.5;
            }
        }

        /* 加密消息样式 */
        .message-content img,
        .message-content video,
        .message-content audio {
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            max-width: 200px;
            max-height: 200px;
            display: block;
            margin: 5px 0;
            transition: transform 0.2s ease;
        }

        .message-content img:hover,
        .message-content video:hover {
            transform: scale(1.05);
            cursor: pointer;
        }

        /* 媒体全屏覆盖层 */
        .media-overlay {
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="intro-screen" id="introScreen">
            <h1>zc和lcz的温馨小窝</h1>
            <div class="input-container">
                <p style="font-size: 1.2rem; margin-bottom: 20px; color: rgba(255, 255, 255, 0.9);">欢迎来到我们的小小世界</p>
                <button id="startBtn">进入我们的小窝</button>
            </div>
        </div>

        <div class="love-screen" id="loveScreen">
            <div class="heart-container"></div>
            <div class="message-container">
                <h2 id="personName"></h2>
                <div id="loveMessage"></div>
                <div class="fireworks-container"></div>
            </div>
            <button id="nextBtn" class="btn-next">下一页</button>
            <div class="stars-container"></div>
        </div>

        <div class="final-screen" id="finalScreen" style="background: linear-gradient(135deg, #0a0a15, #1a1a2e);">
            <div class="final-message">
                <h2>我们的爱情小窝</h2>
                <p id="finalText" style="margin-bottom: 10px;">
                    zc ❤️ lcz<br>
                    你们的专属时光记录
                </p>

                <!-- 照片框 -->
                <div class="photo-frame">
                    <div id="photoDisplay" class="photo-placeholder"
                        style="position:relative; width:100%; height:100%; display:flex; flex-direction:column; justify-content:center; align-items:center;">
                        <span id="photoText">zc和lcz的甜蜜合照</span>
                        <input type="file" id="photoUpload" accept="image/*" style="display:none">
                        <button id="uploadBtn" style="background: linear-gradient(45deg, #ff758c, #ff7eb3); 
                                border: none; 
                                color: white; 
                                padding: 8px 15px; 
                                border-radius: 20px; 
                                cursor: pointer; 
                                font-size: 14px;
                                margin-top: 10px;">
                            选择照片
                        </button>
                        <button id="resetPhotoBtn"
                            style="position:absolute; top:5px; right:5px; background:rgba(0,0,0,0.5); color:white; border:none; border-radius:50%; width:24px; height:24px; font-size:12px; display:none; cursor:pointer; z-index:10;">×</button>
                    </div>
                </div>

                <!-- 按钮区域 - 调整更大更好点击 -->
                <div class="action-buttons"
                    style="display: flex; justify-content: center; gap: 15px; margin-top: 20px; flex-wrap: wrap;">
                    <a href="functions.html" id="functionsBtn"
                        style="display: flex; align-items: center; justify-content: center; padding: 12px 20px; background: linear-gradient(45deg, #FF0000, #FF8000); border: 3px solid rgba(255, 255, 0, 0.5); border-radius: 30px; color: white; font-size: 16px; cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.3); min-width: 120px; text-decoration: none; animation: pulse 1.5s infinite;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                            style="margin-right: 8px;">
                            <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                            <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
                        </svg>
                        进入功能中心
                    </a>
                </div>
            </div>

            <!-- 新增聊天界面 -->
            <div class="chat-container" id="chatContainer"
                style="display: none; position: fixed; z-index: 1000; width: 90%; max-width: 500px; height: 80%; max-height: 600px; background: rgba(20, 30, 48, 0.95); border-radius: 15px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5); flex-direction: column; overflow: hidden; border: 1px solid rgba(255, 117, 140, 0.3); left: 50%; top: 50%; transform: translate(-50%, -50%);">
                <div class="chat-header"
                    style="padding: 15px; background: linear-gradient(45deg, #ff758c, #ff7eb3); display: flex; justify-content: space-between; align-items: center;">
                    <h3 style="margin: 0; color: white; font-size: 1.2rem;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                            style="margin-right: 8px; vertical-align: middle;">
                            <path
                                d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z">
                            </path>
                        </svg>
                        zc和lcz的小小聊天室
                    </h3>
                    <div id="statusIndicator" style="font-size: 12px; color: white; margin-right: 10px;">连接中...</div>
                    <div style="display: flex; align-items: center;">
                        <button id="shareBtn" title="分享链接"
                            style="background: none; border: none; color: white; font-size: 18px; cursor: pointer; margin-right: 5px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <circle cx="18" cy="5" r="3"></circle>
                                <circle cx="6" cy="12" r="3"></circle>
                                <circle cx="18" cy="19" r="3"></circle>
                                <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
                                <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
                            </svg>
                        </button>
                        <button id="closeChatBtn" class="close-btn"
                            style="background: none; border: none; color: white; font-size: 24px; cursor: pointer; box-shadow: none; padding: 0 10px;">×</button>
                    </div>
                </div>
                <div id="typingIndicator"
                    style="display: none; padding: 5px 15px; font-size: 12px; color: rgba(255,255,255,0.7); background-color: rgba(20, 30, 48, 0.9);">
                    正在输入...
                </div>
                <div class="chat-messages" id="chatMessages"
                    style="flex: 1; padding: 15px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; background-color: rgba(20, 30, 48, 0.8);">
                    <!-- 消息将在这里显示 -->
                </div>
                <!-- 多媒体工具栏会由JavaScript动态添加 -->
                <div class="chat-input"
                    style="padding: 15px; display: flex; gap: 10px; background: rgba(0, 0, 0, 0.2); border-top: 1px solid rgba(255, 255, 255, 0.1);">
                    <select id="userSelect"
                        style="min-width: 60px; width: 90px; padding: 10px; border: none; border-radius: 30px; background: rgba(255, 255, 255, 0.1); color: white; outline: none; cursor: pointer; -webkit-appearance: none; appearance: none; background-image: url('data:image/svg+xml;utf8,<svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;white&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot;><polyline points=&quot;6 9 12 15 18 9&quot;></polyline></svg>'); background-repeat: no-repeat; background-position: right 10px center; background-size: 15px; padding-right: 30px;">
                        <option value="zc">zc</option>
                        <option value="lcz">lcz</option>
                    </select>
                    <input type="text" id="messageInput" placeholder="输入留言..." maxlength="100"
                        style="flex: 1; padding: 12px 20px; border: 2px solid rgba(255, 117, 140, 0.5); border-radius: 30px; background: rgba(255, 255, 255, 0.1); color: white; font-size: 16px; outline: none;">
                    <button id="sendBtn"
                        style="min-width: 80px; padding: 10px 20px; border-radius: 30px; background: linear-gradient(45deg, #ff758c, #ff7eb3); border: none; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; font-weight: bold;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                            style="margin-right: 5px;">
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                        发送
                    </button>
                </div>
            </div>
        </div>
    </div>

    <audio id="bgMusic" loop>
        <source src="https://file-examples.com/storage/feaade38c1651bd01984236/2017/11/file_example_MP3_700KB.mp3"
            type="audio/mpeg">
    </audio>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>
    <!-- 添加CryptoJS库用于加密 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

    <script>
        // Firebase配置
        const firebaseConfig = {
            apiKey: "AIzaSyD8Iwxm9wECPAA_wey6vCPeGFz_USv8-JI",
            authDomain: "zc-lcz-love-chat.firebaseapp.com",
            databaseURL: "https://zc-lcz-love-chat-default-rtdb.firebaseio.com",
            projectId: "zc-lcz-love-chat",
            storageBucket: "zc-lcz-love-chat.appspot.com",
            messagingSenderId: "404788494356",
            appId: "1:404788494356:web:b2e8a8a04f9d25fdcb2cc1"
        };

        // 初始化Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const messagesRef = database.ref('messages');
        const statusRef = database.ref('status');
        const typingRef = database.ref('typing');
        // 初始化Firebase Storage用于多媒体上传
        const storage = firebase.storage();
        const storageRef = storage.ref();

        // 加密密钥 - 你们的专属密钥，不会上传到服务器
        let encryptionKey = '';

        // 用于存储当前会话ID
        let sessionId = Date.now().toString() + Math.floor(Math.random() * 1000);

        // 用户已验证标志
        let userVerified = false;
    </script>

    <script>
        // 修改密码管理逻辑
        document.addEventListener('DOMContentLoaded', function () {
            // 密码验证
            const passwordLayer = document.getElementById('passwordLayer');
            const chatPassword = document.getElementById('chatPassword');
            const unlockBtn = document.getElementById('unlockBtn');
            const passwordError = document.getElementById('passwordError');

            // 确保密码层最初显示
            passwordLayer.style.display = 'flex';
            userVerified = false;

            // 全局密码存储相关
            const STORAGE_PREFIX = "lcz_zc_secure_";
            const LOCAL_PASSWORD_KEY = STORAGE_PREFIX + "pwd_hash";
            const LOCAL_SALT_KEY = STORAGE_PREFIX + "salt";
            const LOCAL_VERIFICATION_KEY = STORAGE_PREFIX + "verification";
            const GLOBAL_PASSWORD_ID = "global_password_id"; // 用于标识全局密码ID
            const MESSAGES_PASSWORD_ID = "messages_password_id"; // 用于标识消息加密的密码ID

            // 获取或生成加密盐值
            let salt = localStorage.getItem(LOCAL_SALT_KEY);
            if (!salt) {
                // 生成随机盐值 (32字节)
                const randomArray = new Uint8Array(32);
                window.crypto.getRandomValues(randomArray);
                salt = Array.from(randomArray).map(b => b.toString(16).padStart(2, '0')).join('');
                localStorage.setItem(LOCAL_SALT_KEY, salt);
            }

            // 增强版密码哈希函数 - 使用PBKDF2算法
            async function generateSecureHash(password, salt) {
                // 将密码和盐值转换为ArrayBuffer
                const encoder = new TextEncoder();
                const passwordData = encoder.encode(password);
                const saltData = encoder.encode(salt);

                // 使用密码导入密钥
                const passwordKey = await window.crypto.subtle.importKey(
                    'raw',
                    passwordData,
                    { name: 'PBKDF2' },
                    false,
                    ['deriveBits']
                );

                // 使用PBKDF2导出密钥位 (50,000次迭代，增加暴力破解难度)
                const derivedBits = await window.crypto.subtle.deriveBits(
                    {
                        name: 'PBKDF2',
                        salt: saltData,
                        iterations: 50000,
                        hash: 'SHA-256'
                    },
                    passwordKey,
                    256
                );

                // 转换为十六进制字符串
                const hashArray = Array.from(new Uint8Array(derivedBits));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            // 生成验证字符串 - 用于验证密码是否正确
            async function generateVerificationString(password) {
                // 创建一个固定的验证文本
                const verificationText = "zc_loves_lcz_verified_2024";

                // 使用AES-GCM加密验证文本
                const encoder = new TextEncoder();
                const keyMaterial = await window.crypto.subtle.importKey(
                    'raw',
                    encoder.encode(password),
                    { name: 'PBKDF2' },
                    false,
                    ['deriveBits', 'deriveKey']
                );

                // 派生AES-GCM使用的密钥
                const key = await window.crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: encoder.encode(salt),
                        iterations: 10000,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    { name: 'AES-GCM', length: 256 },
                    false,
                    ['encrypt']
                );

                // 生成随机IV
                const iv = window.crypto.getRandomValues(new Uint8Array(12));

                // 加密验证文本
                const encryptedData = await window.crypto.subtle.encrypt(
                    {
                        name: 'AES-GCM',
                        iv: iv
                    },
                    key,
                    encoder.encode(verificationText)
                );

                // 组合IV和加密数据
                const encryptedArray = new Uint8Array(iv.length + encryptedData.byteLength);
                encryptedArray.set(iv, 0);
                encryptedArray.set(new Uint8Array(encryptedData), iv.length);

                // 转换为Base64字符串
                return btoa(String.fromCharCode.apply(null, encryptedArray));
            }

            // 验证密码是否正确
            async function verifyPassword(password, storedVerification) {
                try {
                    // 解析Base64编码的验证字符串
                    const encryptedArray = new Uint8Array(
                        atob(storedVerification).split('').map(char => char.charCodeAt(0))
                    );

                    // 提取IV (前12字节)
                    const iv = encryptedArray.slice(0, 12);

                    // 提取加密数据
                    const encryptedData = encryptedArray.slice(12);

                    // 导入密钥材料
                    const encoder = new TextEncoder();
                    const keyMaterial = await window.crypto.subtle.importKey(
                        'raw',
                        encoder.encode(password),
                        { name: 'PBKDF2' },
                        false,
                        ['deriveBits', 'deriveKey']
                    );

                    // 派生解密用的密钥
                    const key = await window.crypto.subtle.deriveKey(
                        {
                            name: 'PBKDF2',
                            salt: encoder.encode(salt),
                            iterations: 10000,
                            hash: 'SHA-256'
                        },
                        keyMaterial,
                        { name: 'AES-GCM', length: 256 },
                        false,
                        ['decrypt']
                    );

                    // 尝试解密
                    const decryptedData = await window.crypto.subtle.decrypt(
                        {
                            name: 'AES-GCM',
                            iv: iv
                        },
                        key,
                        encryptedData
                    );

                    // 检查解密结果
                    const decryptedText = new TextDecoder().decode(decryptedData);
                    return decryptedText === "zc_loves_lcz_verified_2024";
                } catch (error) {
                    console.error("验证失败:", error);
                    return false;
                }
            }

            // 生成密码ID，用于标识不同的密码和确定是否需要重置消息
            async function generatePasswordId(password) {
                const encoder = new TextEncoder();
                const data = encoder.encode(password);
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substring(0, 16);
            }

            // 将密码保存到所有Storage区域
            function saveGlobalPassword(password, passwordId) {
                // 保存到localStorage
                localStorage.setItem(GLOBAL_PASSWORD_ID, passwordId);

                // 保存到sessionStorage (用于当前会话共享)
                sessionStorage.setItem(GLOBAL_PASSWORD_ID, passwordId);
                sessionStorage.setItem('current_password', password);

                // 设置全局变量
                window.globalPasswordId = passwordId;
                window.currentPassword = password;

                // 将密码ID保存到数据库以便同步
                database.ref('settings/globalPasswordId').set(passwordId);
            }

            // 处理解锁按钮点击
            unlockBtn.addEventListener('click', async function () {
                const password = chatPassword.value.trim();
                if (!password) {
                    passwordError.textContent = '请输入密码';
                    passwordError.style.display = 'block';
                    return;
                }

                try {
                    // 检查本地存储中是否有验证字符串
                    const storedVerification = localStorage.getItem(LOCAL_VERIFICATION_KEY);
                    const storedHash = localStorage.getItem(LOCAL_PASSWORD_KEY);

                    // 生成当前密码的ID
                    const currentPasswordId = await generatePasswordId(password);

                    // 如果没有存储的验证字符串，这是首次设置密码
                    if (!storedVerification || !storedHash) {
                        // 生成增强的密码哈希
                        const secureHash = await generateSecureHash(password, salt);

                        // 生成验证字符串
                        const verification = await generateVerificationString(password);

                        // 存储到本地
                        localStorage.setItem(LOCAL_PASSWORD_KEY, secureHash);
                        localStorage.setItem(LOCAL_VERIFICATION_KEY, verification);

                        // 设置全局密码
                        saveGlobalPassword(password, currentPasswordId);
                        localStorage.setItem(MESSAGES_PASSWORD_ID, currentPasswordId);

                        // 使用密码作为加密密钥
                        encryptionKey = password;
                        passwordLayer.style.display = 'none';
                        userVerified = true;

                        // 初始化聊天
                        initializeChat();
                        console.log("首次设置密码成功");

                        // 在Firebase中存储一个随机标识符（不是真正的密码哈希）
                        // 这样管理员无法获取真实密码
                        const randomIdentifier = Math.random().toString(36).substring(2, 15) +
                            Math.random().toString(36).substring(2, 15);
                        database.ref('settings/identifier').set(randomIdentifier);
                    } else {
                        // 生成当前输入密码的哈希
                        const inputHash = await generateSecureHash(password, salt);

                        // 首先比较哈希值（快速检查）
                        if (inputHash === storedHash) {
                            // 再进行验证字符串验证（双重检查）
                            const isValid = await verifyPassword(password, storedVerification);

                            if (isValid) {
                                // 密码正确 - 检查是否与上次使用的密码相同
                                const storedPasswordId = localStorage.getItem(GLOBAL_PASSWORD_ID);
                                const messagesPasswordId = localStorage.getItem(MESSAGES_PASSWORD_ID);

                                // 更新全局密码
                                saveGlobalPassword(password, currentPasswordId);

                                // 检查是否需要重置消息
                                if (messagesPasswordId && messagesPasswordId !== currentPasswordId) {
                                    // 提示用户密码已更改，将清除所有消息
                                    if (confirm('检测到密码已更改。为确保安全，所有聊天记录将被清除。是否继续？')) {
                                        // 清除消息
                                        await messagesRef.remove();
                                        // 更新消息密码ID
                                        localStorage.setItem(MESSAGES_PASSWORD_ID, currentPasswordId);
                                    } else {
                                        // 用户取消，提示需要使用原密码
                                        passwordError.textContent = '请使用原密码登录或确认清除消息';
                                        passwordError.style.display = 'block';
                                        return;
                                    }
                                }

                                // 密码正确
                                encryptionKey = password;
                                passwordLayer.style.display = 'none';
                                userVerified = true;
                                initializeChat();
                                console.log("密码验证成功");
                            } else {
                                // 验证失败
                                passwordError.textContent = '密码不正确，请重试';
                                passwordError.style.display = 'block';
                                console.log("密码验证失败 - 验证字符串不匹配");
                            }
                        } else {
                            // 密码错误
                            passwordError.textContent = '密码不正确，请重试';
                            passwordError.style.display = 'block';
                            console.log("密码验证失败 - 哈希不匹配");
                        }
                    }
                } catch (error) {
                    console.error("密码处理过程中出错:", error);
                    passwordError.textContent = '系统错误，请重试';
                    passwordError.style.display = 'block';
                }
            });

            // 按回车键提交密码
            chatPassword.addEventListener('keypress', function (e) {
                if (e.key === 'Enter') {
                    unlockBtn.click();
                }
            });

            // 尝试从会话存储中获取密码 (用于页面间共享)
            const sessionPassword = sessionStorage.getItem('current_password');
            if (sessionPassword) {
                chatPassword.value = sessionPassword;
                // 自动点击解锁按钮尝试验证
                setTimeout(() => {
                    unlockBtn.click();
                }, 500);
            } else {
                // 如果没有会话密码，尝试从URL参数获取密码
                const urlParams = new URLSearchParams(window.location.search);
                const autoPassword = urlParams.get('p');
                if (autoPassword) {
                    chatPassword.value = autoPassword;
                    // 自动清除URL参数
                    window.history.replaceState({}, document.title, window.location.pathname);
                    // 自动点击解锁按钮尝试验证
                    setTimeout(() => {
                        unlockBtn.click();
                    }, 500);
                }
            }
        });

        // 增强型消息加密函数 - 使用AES-GCM模式
        async function encryptMessage(message) {
            try {
                // 创建从密码派生的加密密钥
                const encoder = new TextEncoder();
                const keyMaterial = await window.crypto.subtle.importKey(
                    'raw',
                    encoder.encode(encryptionKey),
                    { name: 'PBKDF2' },
                    false,
                    ['deriveBits', 'deriveKey']
                );

                // 使用当前会话ID和固定字符串作为盐值
                const saltString = "zc_lcz_secure_messaging_" + sessionId.substring(0, 8);

                // 派生AES-GCM密钥
                const key = await window.crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: encoder.encode(saltString),
                        iterations: 1000, // 较低的迭代次数以提高性能，因为我们在频繁加密消息
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    { name: 'AES-GCM', length: 256 },
                    false,
                    ['encrypt']
                );

                // 生成随机IV (12字节)
                const iv = window.crypto.getRandomValues(new Uint8Array(12));

                // 加密消息
                const encryptedData = await window.crypto.subtle.encrypt(
                    {
                        name: 'AES-GCM',
                        iv: iv
                    },
                    key,
                    encoder.encode(message)
                );

                // 组合IV和加密数据
                const result = new Uint8Array(iv.length + encryptedData.byteLength);
                result.set(iv, 0);
                result.set(new Uint8Array(encryptedData), iv.length);

                // 转换为Base64字符串
                return btoa(String.fromCharCode.apply(null, result));
            } catch (error) {
                console.error('增强加密失败:', error);
                // 作为后备，使用CryptoJS
                return 'fallback:' + CryptoJS.AES.encrypt(message, encryptionKey).toString();
            }
        }

        // 增强型消息解密函数
        async function decryptMessage(encrypted) {
            try {
                // 检查是否为后备加密
                if (encrypted.startsWith('fallback:')) {
                    const fallbackData = encrypted.substring(9);
                    const bytes = CryptoJS.AES.decrypt(fallbackData, encryptionKey);
                    return bytes.toString(CryptoJS.enc.Utf8);
                }

                // 解析Base64字符串
                const encryptedArray = new Uint8Array(
                    atob(encrypted).split('').map(char => char.charCodeAt(0))
                );

                // 提取IV和加密数据
                const iv = encryptedArray.slice(0, 12);
                const encryptedData = encryptedArray.slice(12);

                // 创建从密码派生的解密密钥
                const encoder = new TextEncoder();
                const keyMaterial = await window.crypto.subtle.importKey(
                    'raw',
                    encoder.encode(encryptionKey),
                    { name: 'PBKDF2' },
                    false,
                    ['deriveBits', 'deriveKey']
                );

                // 使用和加密相同的盐值
                const saltString = "zc_lcz_secure_messaging_" + sessionId.substring(0, 8);

                // 派生AES-GCM密钥
                const key = await window.crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: encoder.encode(saltString),
                        iterations: 1000,
                        hash: 'SHA-256'
                    },
                    keyMaterial,
                    { name: 'AES-GCM', length: 256 },
                    false,
                    ['decrypt']
                );

                // 解密数据
                const decryptedData = await window.crypto.subtle.decrypt(
                    {
                        name: 'AES-GCM',
                        iv: iv
                    },
                    key,
                    encryptedData
                );

                // 解码为字符串
                return new TextDecoder().decode(decryptedData);
            } catch (error) {
                console.error('解密失败:', error);

                // 尝试使用旧方法解密
                try {
                    const bytes = CryptoJS.AES.decrypt(encrypted, encryptionKey);
                    return bytes.toString(CryptoJS.enc.Utf8);
                } catch (fallbackError) {
                    console.error('后备解密也失败:', fallbackError);
                    return '[无法解密的消息]';
                }
            }
        }

        // 初始化聊天功能
        function initializeChat() {
            // 分享功能
            const shareBtn = document.getElementById('shareBtn');
            if (shareBtn) {
                shareBtn.addEventListener('click', function () {
                    // 创建带密码的链接
                    const currentUrl = window.location.href.split('?')[0]; // 移除现有参数
                    const shareUrl = `${currentUrl}?p=${encodeURIComponent(encryptionKey)}`;

                    // 尝试使用Web Share API
                    if (navigator.share) {
                        navigator.share({
                            title: 'zc和lcz的温馨小窝',
                            text: '点击链接进入我们的专属聊天室',
                            url: shareUrl
                        }).catch(err => {
                            console.error('分享失败:', err);
                            copyToClipboard(shareUrl);
                        });
                    } else {
                        // 后备方案：复制到剪贴板
                        copyToClipboard(shareUrl);
                    }
                });
            }

            // 绑定发送消息事件
            document.getElementById('sendBtn').addEventListener('click', function () {
                sendMessageToFirebase();
            });

            // 按Enter键发送消息
            document.getElementById('messageInput').addEventListener('keypress', function (e) {
                if (e.key === 'Enter') {
                    sendMessageToFirebase();
                }
            });

            // 加载实时消息
            loadFirebaseMessages();

            // 设置在线状态
            setupOnlineStatus();

            // 设置正在输入状态
            setupTypingIndicator();

            // 获取元素
            var chatBtn = document.getElementById('chatBtn');
            var chatContainer = document.getElementById('chatContainer');
            var closeChatBtn = document.getElementById('closeChatBtn');
            var userSelect = document.getElementById('userSelect');

            // 用户切换身份时更新在线状态
            userSelect.addEventListener('change', function () {
                if (statusRef) {
                    statusRef.child(sessionId).update({
                        user: userSelect.value,
                        lastActive: firebase.database.ServerValue.TIMESTAMP
                    });
                }
            });
        }

        // 发送消息到Firebase
        async function sendMessageToFirebase(type = 'text', content = null) {
            if (!userVerified) return;

            var userSelect = document.getElementById('userSelect');
            var sender = userSelect.value;
            var sendBtn = document.getElementById('sendBtn');

            // 禁用发送按钮防止重复发送
            sendBtn.disabled = true;
            sendBtn.textContent = '发送中...';

            // 创建基本消息对象
            var newMessage = {
                sender: sender,
                timestamp: firebase.database.ServerValue.TIMESTAMP,
                type: type
            };

            // 根据消息类型处理内容
            if (type === 'text') {
                var messageInput = document.getElementById('messageInput');
                var message = messageInput.value.trim();
                if (!message) {
                    sendBtn.disabled = false;
                    sendBtn.textContent = '发送';
                    return;
                }

                try {
                    // 使用增强型加密
                    newMessage.text = await encryptMessage(message);
                    // 添加消息摘要用于验证
                    newMessage.digest = CryptoJS.SHA256(message).toString().substring(0, 16);

                    // 推送消息到Firebase
                    await messagesRef.push(newMessage);
                    console.log('消息发送成功');
                    // 清空输入框
                    messageInput.value = '';
                } catch (error) {
                    console.error('消息发送失败:', error);
                    alert('消息发送失败，请重试！');
                } finally {
                    // 恢复发送按钮
                    sendBtn.disabled = false;
                    sendBtn.textContent = '发送';
                }
            } else if (['image', 'video', 'audio'].includes(type) && content) {
                // 处理多媒体消息上传
                try {
                    // 创建唯一的文件名
                    const fileName = `${type}_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
                    const fileRef = storageRef.child(`${sender}/${fileName}`);

                    // 上传文件到Firebase Storage
                    const snapshot = await fileRef.put(content);

                    // 获取下载URL
                    const downloadURL = await snapshot.ref.getDownloadURL();

                    // 加密URL
                    newMessage.url = await encryptMessage(downloadURL);

                    // 推送消息到Firebase
                    await messagesRef.push(newMessage);
                    console.log('多媒体消息发送成功');
                } catch (error) {
                    console.error('多媒体消息发送失败:', error);
                    alert(`${type}发送失败，请重试！`);
                } finally {
                    // 恢复发送按钮
                    sendBtn.disabled = false;
                    sendBtn.textContent = '发送';
                }
            } else {
                sendBtn.disabled = false;
                sendBtn.textContent = '发送';
            }
        }

        // 加载Firebase消息
        function loadFirebaseMessages() {
            if (!userVerified) return;

            const chatMessages = document.getElementById('chatMessages');

            // 监听新消息
            messagesRef.orderByChild('timestamp').on('child_added', function (snapshot) {
                const message = snapshot.val();

                // 创建消息元素占位符
                const msgElement = document.createElement('div');
                msgElement.classList.add('message', message.sender, 'message-loading');
                msgElement.innerHTML = '<div class="message-loading-indicator">消息加载中...</div>';
                chatMessages.appendChild(msgElement);

                // 异步处理消息内容
                processMessageContent(message, msgElement).then(() => {
                    // 移除加载指示器
                    msgElement.classList.remove('message-loading');
                    // 滚动到最新消息
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }).catch(error => {
                    console.error('处理消息失败:', error);
                    msgElement.innerHTML = `
                        <div class="message-sender">${message.sender}</div>
                        <div class="message-content">[消息加载失败]</div>
                    `;
                });
            });
        }

        // 异步处理消息内容
        async function processMessageContent(message, msgElement) {
            try {
                // 格式化时间
                const date = new Date(message.timestamp);
                const formattedTime = date.getHours().toString().padStart(2, '0') + ':' +
                    date.getMinutes().toString().padStart(2, '0');

                // 尝试解密消息
                let messageContent = '';

                if (message.type === 'text') {
                    // 文本消息
                    const decryptedText = await decryptMessage(message.text);
                    messageContent = `<div class="message-content">${decryptedText}</div>`;
                } else if (message.type === 'image') {
                    // 图片消息
                    const imageUrl = await decryptMessage(message.url);
                    messageContent = `
                        <div class="message-content">
                            <img src="${imageUrl}" class="message-image" style="max-width: 200px; max-height: 200px; border-radius: 8px; cursor: pointer;" onclick="showFullScreenMedia('${imageUrl}', 'image')">
                        </div>`;
                } else if (message.type === 'video') {
                    // 视频消息
                    const videoUrl = await decryptMessage(message.url);
                    messageContent = `
                        <div class="message-content">
                            <video controls class="message-video" style="max-width: 200px; max-height: 200px; border-radius: 8px; cursor: pointer;" onclick="showFullScreenMedia('${videoUrl}', 'video')">
                                <source src="${videoUrl}" type="video/mp4">
                                你的浏览器不支持视频标签
                            </video>
                        </div>`;
                } else if (message.type === 'audio') {
                    // 语音消息
                    const audioUrl = await decryptMessage(message.url);
                    messageContent = `
                        <div class="message-content">
                            <audio controls class="message-audio" style="max-width: 200px;">
                                <source src="${audioUrl}" type="audio/mpeg">
                                你的浏览器不支持音频标签
                            </audio>
                        </div>`;
                } else {
                    // 默认为文本消息
                    try {
                        const decryptedText = await decryptMessage(message.text || '');
                        messageContent = `<div class="message-content">${decryptedText}</div>`;
                    } catch (e) {
                        messageContent = `<div class="message-content">[未知消息类型]</div>`;
                    }
                }

                msgElement.innerHTML = `
                    <div class="message-sender">${message.sender}</div>
                    ${messageContent}
                    <div class="message-time">${formattedTime}</div>
                `;
            } catch (error) {
                console.error('消息处理失败:', error);
                msgElement.innerHTML = `
                    <div class="message-sender">${message.sender}</div>
                    <div class="message-content">[无法解密的消息]</div>
                    <div class="message-time">--:--</div>
                `;
            }
        }

        // 全屏查看媒体内容
        function showFullScreenMedia(url, type) {
            // 创建全屏查看容器
            const overlay = document.createElement('div');
            overlay.classList.add('media-overlay');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.9);
                z-index: 1000;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
            `;

            // 添加关闭按钮
            const closeBtn = document.createElement('div');
            closeBtn.innerHTML = `
                <svg width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                    <path d="M18 6L6 18M6 6l12 12"></path>
                </svg>
            `;
            closeBtn.style.cssText = `
                position: absolute;
                top: 20px;
                right: 20px;
                cursor: pointer;
                z-index: 1001;
            `;
            closeBtn.onclick = () => document.body.removeChild(overlay);

            // 创建媒体元素
            let mediaElement;
            if (type === 'image') {
                mediaElement = document.createElement('img');
                mediaElement.src = url;
                mediaElement.style.cssText = `
                    max-width: 90%;
                    max-height: 80%;
                    object-fit: contain;
                    border-radius: 8px;
                    box-shadow: 0 4px 16px rgba(0,0,0,0.5);
                `;
            } else if (type === 'video') {
                mediaElement = document.createElement('video');
                mediaElement.controls = true;
                mediaElement.autoplay = true;
                const source = document.createElement('source');
                source.src = url;
                source.type = 'video/mp4';
                mediaElement.appendChild(source);
                mediaElement.style.cssText = `
                    max-width: 90%;
                    max-height: 80%;
                    border-radius: 8px;
                    box-shadow: 0 4px 16px rgba(0,0,0,0.5);
                `;
            }

            // 添加到DOM
            overlay.appendChild(closeBtn);
            overlay.appendChild(mediaElement);
            document.body.appendChild(overlay);
        }

        // 设置在线状态
        function setupOnlineStatus() {
            const statusIndicator = document.getElementById('statusIndicator');

            // 更新在线状态
            const userStatusRef = statusRef.child(sessionId);

            // 设置当前用户为在线
            userStatusRef.set({
                online: true,
                lastActive: firebase.database.ServerValue.TIMESTAMP,
                user: document.getElementById('userSelect').value
            });

            // 断开连接时自动设置为离线
            userStatusRef.onDisconnect().remove();

            // 监听连接状态
            const connectedRef = firebase.database().ref('.info/connected');
            connectedRef.on('value', (snap) => {
                if (snap.val() === true) {
                    statusIndicator.textContent = '已连接';
                    statusIndicator.style.color = '#4caf50';
                } else {
                    statusIndicator.textContent = '连接中...';
                    statusIndicator.style.color = 'orange';
                }
            });

            // 监听其他用户状态变化
            statusRef.on('value', (snapshot) => {
                const onlineUsers = [];
                snapshot.forEach((childSnapshot) => {
                    const userData = childSnapshot.val();
                    if (userData.online && childSnapshot.key !== sessionId) {
                        onlineUsers.push(userData.user);
                    }
                });

                if (onlineUsers.length > 0) {
                    const otherUser = onlineUsers.join('、');
                    statusIndicator.textContent = `${otherUser} 在线`;
                    statusIndicator.style.color = '#4caf50';
                } else if (connectedRef.key) {
                    statusIndicator.textContent = '已连接';
                }
            });
        }

        // 设置正在输入状态
        function setupTypingIndicator() {
            const messageInput = document.getElementById('messageInput');
            const typingIndicator = document.getElementById('typingIndicator');
            const userSelect = document.getElementById('userSelect');
            let typingTimeout = null;

            // 当用户开始输入时
            messageInput.addEventListener('input', () => {
                // 更新正在输入状态
                typingRef.child(sessionId).set({
                    typing: true,
                    user: userSelect.value,
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                });

                // 清除之前的超时
                if (typingTimeout) {
                    clearTimeout(typingTimeout);
                }

                // 设置5秒后自动清除状态
                typingTimeout = setTimeout(() => {
                    typingRef.child(sessionId).remove();
                }, 5000);
            });

            // 监听其他用户的输入状态
            typingRef.on('value', (snapshot) => {
                let someoneTyping = false;
                let typingUser = '';

                snapshot.forEach((childSnapshot) => {
                    const data = childSnapshot.val();
                    // 只显示其他用户的输入状态
                    if (childSnapshot.key !== sessionId && data.typing) {
                        someoneTyping = true;
                        typingUser = data.user;

                        // 检查是否输入状态过期(超过6秒)
                        const now = Date.now();
                        if (now - data.timestamp > 6000) {
                            someoneTyping = false;
                            typingRef.child(childSnapshot.key).remove();
                        }
                    }
                });

                if (someoneTyping) {
                    typingIndicator.textContent = `${typingUser} 正在输入...`;
                    typingIndicator.style.display = 'block';
                } else {
                    typingIndicator.style.display = 'none';
                }
            });

            // 发送消息后清除输入状态
            document.getElementById('sendBtn').addEventListener('click', () => {
                typingRef.child(sessionId).remove();
            });

            // 断开连接时清除输入状态
            typingRef.child(sessionId).onDisconnect().remove();
        }

        // 复制到剪贴板
        function copyToClipboard(text) {
            // 创建临时输入框
            const input = document.createElement('input');
            input.value = text;
            document.body.appendChild(input);
            input.select();

            // 复制文本
            try {
                document.execCommand('copy');
                alert('链接已复制到剪贴板!');
            } catch (err) {
                console.error('复制失败:', err);
                alert('无法复制链接: ' + text);
            }

            // 移除临时元素
            document.body.removeChild(input);
        }
    </script>

    <script src="script.js"></script>

    <!-- 确保聊天按钮功能在最终页面正常工作的脚本 -->
    <script>
        // 注册Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('Service Worker 注册成功:', registration);
                    })
                    .catch(error => {
                        console.log('Service Worker 注册失败:', error);
                    });
            });
        }

        // 简化版脚本，直接绑定事件
        document.addEventListener('DOMContentLoaded', function () {
            console.log("绑定UI相关事件");

            // 获取元素
            var chatBtn = document.getElementById('chatBtn');
            var chatContainer = document.getElementById('chatContainer');
            var closeChatBtn = document.getElementById('closeChatBtn');

            // 确保元素存在
            if (chatBtn && chatContainer && closeChatBtn) {
                console.log("找到所有聊天相关元素");

                // 确保没有重复绑定事件
                chatBtn.onclick = null;
                closeChatBtn.onclick = null;

                // 简单直接的事件绑定方式
                chatBtn.onclick = function (e) {
                    console.log("聊天按钮被点击(直接绑定)");
                    // 先检查是否已验证密码
                    if (!userVerified) {
                        // 显示密码验证层
                        document.getElementById('passwordLayer').style.display = 'flex';
                        return false;
                    }

                    chatContainer.style.display = 'flex';
                    chatContainer.classList.add('visible');
                    return false;
                };

                closeChatBtn.onclick = function (e) {
                    console.log("关闭按钮被点击(直接绑定)");
                    chatContainer.style.display = 'none';
                    chatContainer.classList.remove('visible');
                    return false;
                };

                console.log("聊天按钮事件绑定完成");
            } else {
                console.error("未找到聊天相关元素!", {
                    chatBtn: chatBtn,
                    chatContainer: chatContainer,
                    closeChatBtn: closeChatBtn
                });
            }

            // 照片上传功能
            var uploadBtn = document.getElementById('uploadBtn');
            var photoUpload = document.getElementById('photoUpload');
            var photoDisplay = document.getElementById('photoDisplay');
            var photoText = document.getElementById('photoText');
            var resetPhotoBtn = document.getElementById('resetPhotoBtn');

            if (uploadBtn && photoUpload && photoDisplay && resetPhotoBtn) {
                uploadBtn.onclick = function () {
                    photoUpload.click();
                };

                photoUpload.onchange = function (e) {
                    if (this.files && this.files[0]) {
                        var reader = new FileReader();

                        reader.onload = function (e) {
                            // 创建图片元素
                            photoText.style.display = 'none';
                            uploadBtn.style.display = 'none';
                            resetPhotoBtn.style.display = 'block';

                            // 设置背景图片
                            photoDisplay.style.backgroundImage = `url(${e.target.result})`;
                            photoDisplay.style.backgroundSize = 'cover';
                            photoDisplay.style.backgroundPosition = 'center';

                            // 保存图片到本地存储
                            try {
                                // 如果有加密密钥，也对图片进行加密
                                if (encryptionKey && typeof encryptMessage === 'function') {
                                    encryptMessage(e.target.result).then(encryptedPhoto => {
                                        localStorage.setItem('lovePhotoEncrypted', encryptedPhoto);
                                        localStorage.removeItem('lovePhoto'); // 移除明文存储
                                    }).catch(err => {
                                        console.error('加密照片失败:', err);
                                        // 如果加密失败，保存未加密版本
                                        localStorage.setItem('lovePhoto', e.target.result);
                                    });
                                } else {
                                    localStorage.setItem('lovePhoto', e.target.result);
                                }
                            } catch (err) {
                                console.error('保存图片失败，可能是图片太大:', err);
                            }
                        };

                        reader.readAsDataURL(this.files[0]);
                    }
                };

                // 重置照片
                resetPhotoBtn.onclick = function (e) {
                    e.stopPropagation(); // 阻止事件冒泡

                    // 恢复初始状态
                    photoDisplay.style.backgroundImage = '';
                    photoText.style.display = 'block';
                    uploadBtn.style.display = 'block';
                    resetPhotoBtn.style.display = 'none';

                    // 移除存储的照片
                    localStorage.removeItem('lovePhoto');
                    localStorage.removeItem('lovePhotoEncrypted');
                };

                // 检查是否有保存的图片
                var savedPhoto = localStorage.getItem('lovePhoto');
                var encryptedPhoto = localStorage.getItem('lovePhotoEncrypted');

                if (encryptedPhoto && encryptionKey && typeof decryptMessage === 'function') {
                    try {
                        // 尝试解密
                        decryptMessage(encryptedPhoto).then(decryptedPhoto => {
                            photoText.style.display = 'none';
                            uploadBtn.style.display = 'none';
                            resetPhotoBtn.style.display = 'block';
                            photoDisplay.style.backgroundImage = `url(${decryptedPhoto})`;
                            photoDisplay.style.backgroundSize = 'cover';
                            photoDisplay.style.backgroundPosition = 'center';
                        }).catch(err => {
                            console.error('解密照片失败:', err);
                            // 如果无法解密，尝试使用普通模式
                            if (savedPhoto) {
                                photoText.style.display = 'none';
                                uploadBtn.style.display = 'none';
                                resetPhotoBtn.style.display = 'block';
                                photoDisplay.style.backgroundImage = `url(${savedPhoto})`;
                                photoDisplay.style.backgroundSize = 'cover';
                                photoDisplay.style.backgroundPosition = 'center';
                            }
                        });
                    } catch (err) {
                        console.error('解密照片失败:', err);
                        // 如果无法解密，使用普通模式
                        if (savedPhoto) {
                            photoText.style.display = 'none';
                            uploadBtn.style.display = 'none';
                            resetPhotoBtn.style.display = 'block';
                            photoDisplay.style.backgroundImage = `url(${savedPhoto})`;
                            photoDisplay.style.backgroundSize = 'cover';
                            photoDisplay.style.backgroundPosition = 'center';
                        }
                    }
                } else if (savedPhoto) {
                    photoText.style.display = 'none';
                    uploadBtn.style.display = 'none';
                    resetPhotoBtn.style.display = 'block';
                    photoDisplay.style.backgroundImage = `url(${savedPhoto})`;
                    photoDisplay.style.backgroundSize = 'cover';
                    photoDisplay.style.backgroundPosition = 'center';
                }

                // 添加重新上传功能
                photoDisplay.addEventListener('click', function (e) {
                    // 只有当已经有图片时，点击才能更换图片
                    if (photoDisplay.style.backgroundImage) {
                        photoUpload.click();
                    }
                });
            }
        });
    </script>

    <!-- 密码验证层 -->
    <div id="passwordLayer"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; flex-direction: column; justify-content: center; align-items: center;">
        <div
            style="background: rgba(255,255,255,0.1); padding: 30px; border-radius: 15px; max-width: 90%; width: 350px; text-align: center; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5); border: 1px solid rgba(255, 117, 140, 0.3);">
            <h3
                style="margin-bottom: 20px; color: white; font-size: 1.2rem; display: flex; align-items: center; justify-content: center;">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                    style="margin-right: 10px;">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                    <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                </svg>
                请输入密码解锁聊天
            </h3>
            <p style="color: rgba(255,255,255,0.7); font-size: 14px; margin-bottom: 20px;">这将用于加密你们的聊天内容，请记住这个密码</p>
            <div style="position: relative; margin-bottom: 15px;">
                <input type="password" id="chatPassword" placeholder="输入你们的专属密码"
                    style="width: 100%; padding: 12px 15px 12px 40px; border: 1px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.1); color: white; border-radius: 30px; font-size: 16px; outline: none;">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                    style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: rgba(255,255,255,0.7);">
                    <path
                        d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4">
                    </path>
                </svg>
            </div>
            <div id="passwordError" style="color: #ff5555; font-size: 14px; margin-bottom: 15px; display: none;">
                密码不正确，请重试
            </div>
            <button id="unlockBtn"
                style="background: linear-gradient(45deg, #ff758c, #ff7eb3); border: none; color: white; padding: 12px 25px; border-radius: 30px; cursor: pointer; font-weight: bold; width: 100%; display: flex; align-items: center; justify-content: center;">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                    style="margin-right: 8px;">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                    <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                </svg>
                解锁聊天
            </button>
        </div>
    </div>

    <!-- 引入多媒体聊天脚本 -->
    <script src="chat_multimedia.js"></script>

    <!-- 系统检查和修复加载 -->
    <script src="crypto_fixes.js"></script>
    <script src="chat_fixes.js"></script>
    <script src="fix_loader.js"></script>

    <!-- 修复测试脚本 -->
    <script src="fixes_test.js"></script>
</body>

</html>